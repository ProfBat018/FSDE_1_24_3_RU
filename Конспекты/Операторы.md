# Тема урока: Операторы
- Арифметические операторы
- Операторы сравнения
- Логические операторы
- Операторы присваивания
- Операторы инкремента и декремента
- Операторы конкатенации
- Операторы пространства имен
- Операторы типа
- Операторы управления ошибками
- Операторы контроля ошибок


## Арифметические операторы

| Оператор | Описание | Пример |
|----------|----------|--------|
| + | Сложение | $a + $b |
| - | Вычитание | $a - $b |
| * | Умножение | $a * $b |
| / | Деление | $a / $b |
| % | Деление по модулю | $a % $b |

## Операторы сравнения

| Оператор | Описание | Пример |
|----------|----------|--------|
| == | Равно | $a == $b |
| != | Не равно | $a != $b |
| > | Больше | $a > $b |
| < | Меньше | $a < $b |
| >= | Больше или равно | $a >= $b |
| <= | Меньше или равно | $a <= $b |
| is | Тождественно | $a is $b |
| is not | Не тождественно | $a is not $b |


`is` - это новый оператор для вас. 

Он проверяет, являются ли два объекта одним и тем же объектом, а не равными объектами.

```csharp

int a = 5;

if (a is int) 
{
    Console.WriteLine("a is an integer");
}
```

Чаще всего таким образом мы проверяем на `null`


## Логические операторы

Тут все так же. 

## Операторы присваивания

int a, b, c;
a = b = c = 34;

Из интересного, только это

## Операторы инкремента и декремента

Тоже самое 

## Операторы конкатенации

```csharp
string a = "Hello";
string b = "World";
string c = a + b;
```

## Операторы пространства имен

```csharp
// просто используем пространство имен
using System; 

// используем пространство имен глобально во всем проекте
global using System;

// используем статический класс, резульятат будет такой WriteLine("Hello World");
using static System.Console;
global using static System.Console;

```

## Операторы типа

`C#` - настолько высокоуровненвый и строготипизированный язык, что для работы с типами есть тип данных который называется `Type`. 

При это `Type` - это класс, который находится в пространстве имен `System`.

Для него есть методы из namespace `System.Reflection`, которые помогают с помощью рефлексии забирать информацию о типе (Пройдем в будущем)

```csharp
int a = 5;

Console.WriteLine(a.GetType().Name); // System.Int32
```


## Операторы управления ошибками

```csharp

try
{
    // код
}
catch (Exception ex)
{
    // обработка ошибки
}
finally
{
    // код который выполнится в любом случае
}

```

Тут для вас новое это `finally`. Он будет выполнен в любом случае, даже если в блоке `try` произошла ошибка. Он нужен для того, чтобы закрыть ресурсы, которые были открыты в блоке `try`, например файл или связь с сервером. 

`finally` - можно и не писать, а также использовать `try` без `catch`, но тогда это будет просто блок кода, который выполнится в любом случае. 

Это будет выглядеть так:

```csharp

try
{
    // код
}
finally
{
    // код который выполнится в любом случае
}

```

## Операторы контроля ошибок

```csharp

try
{
    // код
}
catch (Exception ex) when (ex is NullReferenceException)
{
    // обработка ошибки
}

```

Эта тема также новая для вас и называется Exception filtering. По сути это дополнительное условие для `catch`. 






