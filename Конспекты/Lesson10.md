# Interfaces

Когда я спрашивал у вас на экзамене про основные принципы ООП, некоторые из вас говорили про 3, а некоторые про 4. В целом это правда, существует 4 принципа ООП. Правда в последнее время все меньше говорят про абстракцию. Перед тем как объяснить вам тему `интерфейсы`, я хочу полностью положить конец обсуждению разницы между абстракцией и полиморфизмом.

Начнем с базы, есть 4 принципа ООП:

1. Инкапсуляция
2. Наследование
3. Полиморфизм
4. Абстракция

`Инкапсуляция` - изменение доступа к сущности. При чем это может быть как ограничение так и добавление дополнительной логики вашим сущностям.

`Наследование` - это передача возможностей, поведения от одной сущности к другой. Например делегирование конструкторов мы тоже можем считать частью наследования. Этот принцип слишком простой для того чтобы приводить новые примеры.

`Полиморфизм` - это изменение базовых возможностей объекта в зависимости от переменных среды(имеется ввиду пространство в котором оно находится, а не то что вы думаете). Он бывает статичным или динамичным. Статичный, как пример поведения знака `+` в зависимости от типа данных. С типом `string` и с типом `int` он работает по другому. Динамический полиморфизм - это когда в зависимости от дочерних классов действия метода работают по разному. Можно вообще упростить все эти академические выражения и сказать что `override` - это статический полиморфизм, а `overloading` - это динамический полиморфизм. Для особой понятности можно выразиться на русском языке и сказать `перегрузка` и `переопределение`.

`Абстракция` - это больше подход в написании кода, нежели применимый концепт ООП. Из-за этого его можно и не говорить, по факту любой высокоуровнеый язык программирования уже содержит в себе абстракцию. Вы не сможете написать нормльный ООП код без абстракции. Использование абстрактных классов, интерфейсов, делегатов, событий - это все абстракция. Делегаты и события мы пройдем в будущем на этом предмете.

## Интерфейсы

Интерфейс - это контракт класса с абстракцией. В интерфейсе нет данных, есть только `behavior`, то есть поведение. Вы можете создавать там методы, свойства, события, но не поля. В голове у себя вы можете сказать что это очень похоже на `abstract class`, но нет. В абстрактном классе вы можете создавать поля, а в интерфейсе нет. В связи с этим, вы не сможете наследоваться от нескольких абстрактных классов, но можете реализовать несколько интерфейсов. Обратите внимание что я использовал слово `реализовать`, а не `наследовать`.

Большинство интерфейсов заканчивается на суффикс `able`. Например `IComparable`, `IDisposable`, `IConvertible`. Это не обязательно, но это хорошая практика. Как раз такое наименование доказывает что интерфейс это контракт который наделяет вас особенными возможностями. Начинатся интерфейс должен обязательно с `I`. Без него компилятор не даст ошибку, но это не хорошая практика.

Раз и навсегда запомните, лучше создать файлы по отдельности. Не надо писать 2 класса в одном файле. Это плохая практика. Это относится ко всем типам которые вы описываете сами. Я за это буду бить.

Не забывайте создавать или же смотреть на `namespace`. Это важно.

```csharp

class Tank : ITransport, IGun
{

}


interface ITransport
{
    void Move();
}

interface IGun
{
    void Shoot();
}

```

В данном примере в классе Tank выйдет ошибка потому что вы обязаны реализовать все методы интерфейсов.

```csharp

class Tank : ITransport, IGun
{
    public void Move()
    {
        throw new NotImplementedException();
    }

    public void Shoot()
    {
        throw new NotImplementedException();
    }
}

```

Там специально написано `throw new NotImplementedException();`. Это значит что метод не реализован. пишем мы это для того чтобы компилятор не ругался что метод пустой и не реализован. К тому же если он не будет ругаться и я его случайно вызову, то получу такую ошибку и сразу пойму в чем дело.

```csharp



ITransport[] transports = new ITransport[2]
{
    new Tank(),
    new Car()
};

IGun[] guns = new IGun[2]
{
    new Tank(),
    new Rifle()
};

class Tank : ITransport, IGun
{
    public void Move()
    {
        Console.WriteLine("Tanl is moving");
    }

    public void Shoot()
    {
        Console.WriteLine("Tank is shooting");
    }
}

class Car : ITransport
{
    public void Move()
    {
        Console.WriteLine("Car is moving");
    }
}

class Rifle : IGun
{
    public void Shoot()
    {
        Console.WriteLine("Rifle is shooting");
    }
}

```

В данном примере вы можете наблюдать явный пример динамического полиморфизма, так как в зависимости от типа данных, методы работают по разному.Вот примерный вывод в консоль:

```
Tank is moving
Car is moving
Tank is shooting
Rifle is shooting
```

Один из самых главных встроенных в C# интерфейсов это `IEnumerable`. Он позволяет вам перебирать коллекции. Все коллекции в C# начиная от массива и заканчивая `List` реализуют этот интерфейс.

```csharp

IEnumerable<int> nums = new int[] { 1, 2, 3, 4, 5 };

foreach (int num in nums)
{
    Console.WriteLine(num);
}

```

или же

```csharp

IEnumerable<int> nums = new List<int> { 1, 2, 3, 4, 5 };

foreach (int num in nums)
{
    Console.WriteLine(num);
}

```

В обоих случаях вы получите одинаковый вывод.

Использование интерфейсов позволяет вам писать более гибкий код. Давайте приведу пример с реальным проектом. Если вы создали класс `MovieService`, то вам надо будет создать методы для добавления, удаления, редактирования фильмов. Если вы создали класс `UserService`, то вам надо будет создать методы для добавления, удаления, редактирования пользователей. В данном случае вы можете создать интерфейс `IService` и реализовать его в обоих классах.

```csharp

interface IService<T>
{
    void Add(T item);
    void Remove(T item);
    void Edit(T item);
}

class MovieService : IService<Movie>
{
    public void Add(Movie item)
    {
        throw new NotImplementedException();
    }

    public void Edit(Movie item)
    {
        throw new NotImplementedException();
    }

    public void Remove(Movie item)
    {
        throw new NotImplementedException();
    }
}

class UserService : IService<User>
{
    public void Add(User item)
    {
        throw new NotImplementedException();
    }

    public void Edit(User item)
    {
        throw new NotImplementedException();
    }

    public void Remove(User item)
    {
        throw new NotImplementedException();
    }
}

```

Также, вы можете возвращать интерфейс как тип из метода, что улучшает гибкость вашего кода.

С C# версии 7.0 в интерфейсках можно создавать методы с реализацией. Компания `Microsoft` добавила этот костыль не для того чтобы вы его использовали, а для того что кпростить заранее неправильно написанный код. Например представьте себе, что вы коряво создали 15 классов которые по никому непонятным причинам создают один и тот же метод. Вместо того, чтобы переписывать все эти классы, вы можете создать метод с реализацией в интерфейсе. Никто не пишет готовый код в интерфесах, при новом проекте это `red flag` что вы что-то делаете не так. Вот пример такого интерфейса:

```csharp

interface ITransport
{
    void Move();
    void Stop()
    {
        Console.WriteLine("Transport is stopped");
    }
}

```

Вы можете спросить что как это может работать, если интерфейс не может содержать реализацию. Все просто, если вы создадите класс который реализует этот интерфейс, то он добавиться в него неявно. Вот пример:

```csharp

class Car : ITransport
{
    public void Move()
    {
        Console.WriteLine("Car is moving");
    }
}

```

Вы видите тут метод `Stop`? Нет. Но он есть.

С этой темой мы еще не закончили и еще очень долго будет ее проходить параллельно с другими темами. К следующему уроку вы должны знать абсолютно наизусть и понимать как работает все то
, что я сказал.
